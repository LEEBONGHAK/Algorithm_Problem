# [빠른 A+B](https://www.acmicpc.net/problem/15552)  
  
### 문제  
  
본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.  
C++을 사용하고 있고 cin/cout을 사용하고자 한다면, cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해 주고, endl 대신 개행문자(\n)를 쓰자. 단, 이렇게 하면 더 이상 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다.  
Java를 사용하고 있다면, Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용할 수 있다. BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다.  
Python을 사용하고 있다면, input 대신 sys.stdin.readline을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다.  
또한 입력과 출력 스트림은 별개이므로, 테스트케이스를 전부 입력받아서 저장한 뒤 전부 출력할 필요는 없다. 테스트케이스를 하나 받은 뒤 하나 출력해도 된다.  
자세한 설명 및 다른 언어의 경우는 [이 글](https://www.acmicpc.net/board/view/22716)에 설명되어 있다.  
  
### 입력  
  
첫 줄에 테스트케이스의 개수 T가 주어진다. T는 최대 1,000,000이다. 다음 T줄에는 각각 두 정수 A와 B가 주어진다. A와 B는 1 이상, 1,000 이하이다.  
  
### 출력  
  
각 테스트케이스마다 A+B를 한 줄에 하나씩 순서대로 출력한다.  
  
### 예제  
  
|입력|출력|
|---|---|
|5<br/>1 1<br/>12 34<br/>5 500<br/>40 60<br/>1000 1000|2<br/>46<br/>505<br/>100<br/>2000|
  
## C++ 빠른 입출력을 위한 방법들 ([원문](https://st-lab.tistory.com/232))  
### C++와 C 표준 스트림의 동기화 해제  
    
`ios_base::sync_with_stdio(false);`  
  
기본적으로 C++에서는 C++와 C의 표준 스트림이 동기화가 되어있다.  
C++에서 C와 C++ 각각의 스타일로 입출력을 받아도 서로 동기화하여 우리가 입력 혹은 출력하고자 하는 순서대로 결과를 얻을 수 있다. 즉, C와 C++가 동일한 버퍼를 공유한다는 것이다.  
(만약 스트림에 대한 개념이 없다면 C와 C++가 입출력을 항시 공유상태라고 이해하는 것이 좀 더 이해가 수월할 것이다.)  
  
이러한 동기화는 성능을 저하시키는 원인이 되지만, 두 스트림의 동기화는 우리가 입출력에 있어 C와 C++의 IO(Input-Output)을 혼용하여 쓸 때 매우 합리적이고 스레드로부터 안전하기 때문에 원래는 동기화 상태로 두는 것이 올바르긴 하다.  
예를 들면 입력의 경우 std::cin은 stdin과 동기화 되며, std::cout은 stdout과 동기화가 된다고 보면 된다.  
  
다만, 알고리즘 문제 풀이에서는 예외 처리나 멀티스레드 작업을 필요로 하지 않기 때문에 두 동기화를 끊어주어도 무방하다.  
  
그럼 동기화를 끊는다는 것은 무엇일까?  
앞서 C 스트림과 C++ 스트림이 서로 동기화 되어있다고 했다. 이 동기화를 끊는 다는 것은 C++ 표준 스트림이 독립적으로 IO 버퍼링을 할 수 있다는 것이다. 그렇게 되면 상당히 많은 양의 입출력이 있을 경우 동기화 되어있는 상태에 비해 성능이 많이 좋아진다.  
즉, 이러한 작업을 위해 `ios_base`에 있는 `sync_with_stdio()` 을 활용하여 위 코드처럼 적용시키면 동기화가 해제 된다.  
직역을 해보면 stdio와의 싱크(동기화) 메소드인 것을 알 수 있다. 여기에 파라미터로 false을 해주면 동기화가 해제되게 된다.  
  
그리고 중요한 점은 동기화를 해제했기 때문에 C와 C++ 스타일 중 하나를 선택해서 써야 한다. 혼용하여 쓰면 안된다.  
  
### 입력과 출력 연결을 끊어주기  
  
`cin.tie(NULL);	// 또는 cin.tie(nullptr), cin.tie(0) 으로 대체 가능`  
  
기본적으로 입력과 출력은 연결되어있다.
즉, 기본적으로 입력 요청이 들어오면 그 전에 출력 작업이 있었을 경우(출력 버퍼에 내용이 있는 경우) 버퍼를 비워(flush) 출력을 하게 된다.  
좀 더 쉽게 말하자면 입력 요청을 통해 읽어들이게 될 경우 이 전에 있던 출력 작업들을 콘솔창에 보이도록 버퍼를 비운다는 것이다.  
  
### `endl` 대신 `"\n"` 쓰기
  
endl은 단순히 개행(줄바꿈)만 해주는 것이 아니라 출력 버퍼를 비우는 역할까지 한다.  
즉, 매 줄 바꿈마다 endl 을 쓰면 우리가 2번에서 다루었던 tie을 끊어주는 것의 효과를 볼 수가 없다.  

또한 바로 위에서 말했듯, 매 번 출력 할 필요가 없으니 자주 출력 버퍼를 비울 이유가 없다.  
이 출력 버퍼를 비우는 작업도 상당히 시간을 잡아먹는 작업이기 때문에 마지막 한 번에 출력을 비우는 것이 좋다.  
(물론 버퍼가 꽉 차면 알아서 비워주니 걱정 안해도 된다.)  